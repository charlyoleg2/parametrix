import"../chunks/DsnmJJEf.js";import"../chunks/B0yeDSe9.js";import{p as E,b as H,f as K,s as t,t as M,e as i,u as o,a as Q,d as a,c as U,r as n}from"../chunks/BbPHKYFl.js";import{s as X}from"../chunks/CqIcUl-F.js";import{h as f}from"../chunks/BeUMq7SC.js";import{s as l}from"../chunks/B32sI_Hj.js";import{i as Y}from"../chunks/HuASpZhE.js";import{l as Z,s as ee}from"../chunks/BW11xtzg.js";import{D as te}from"../chunks/ClSKqFEj.js";import{a as e}from"../chunks/DJ0mkbHa.js";const C={title:"Involute of circle",category:"documentation"},{title:ie,category:fe}=C;var oe=U('<h1> </h1> <h2>Definition of an involute of circle</h2> <p>An <em>involute of circle</em> is the curve drawn by the extremity of a string rolled out from a <em>base circle</em>. The shape of an involute depends only on the size of the <em>base circle</em> (i.e. its radius). An <em>involute of circle</em> is completely defined with the radius of the <em>base circle</em> and the angle of the start position.</p> <p><img alt="involute_of_circle_R0.svg"/> <img alt="negative_involute_of_circle_R0.svg"/></p> <pre class="language-undefined"><!></pre> <p>So we can calculate directly (with a formula):</p> <ul><li>With u, we get L and w</li> <li>With L, we get u and then w</li> <li>With w, we can not get u directly. We can only approximate it iteratively</li></ul> <p>The curve of the <em>involute of circle</em> can be described with <em>polar coordinates</em> as a <em>parametric function</em>:</p> <pre class="language-undefined"><!></pre> <h2>Properties of an involute of circle</h2> <p><img alt="involute_of_circle_Ri1_u0.svg"/> <img alt="involute_of_circle_Ri2_u2.svg"/></p> <pre class="language-undefined"><!></pre> <p>For any initial angle i1 of an <em>involute of circle</em>, we construct the line called <em>line of action</em> or <em>line of pressure</em> going through B, the first point of the involute at the initial position i1 and the angle of inclination i1 - PI / 2. With those definitions we have those results:</p> <ul><li>The angle of inclination of the tangent of B is i1</li> <li>For any rotation of angle j, it exists a point C at the intersection of the involute and the <em>line of action</em></li> <li>The angle of inclination of the tangent of C is i1</li> <li>The distance BC is R*j</li></ul> <p>Conclusion, if we have a plan with an inclination angle i3, it will be pushed by an <em>involute of circle</em> with initial angle i3. The pressure of the involute on the plan is always along the line of inclination angle i3 - PI / 2. This line is called <em>line of pressure</em> or <em>line of action</em>. If the <em>base circle</em> of the involute rotates at a constanst <em>angular speed</em> J, then the plan is pushed at the <em>linear speed</em> RJ with R the radius of the <em>base circle</em>.</p> <h2>Contact point</h2> <p>The <em>position</em> and <em>instant speed</em> of the contact point C of an <em>involute of circle</em> with the virtual plan perpendicular to the <em>line of action</em>.</p> <p><img alt="point_c_position_and_speed_positive.svg"/> <img alt="point_c_position_and_speed_negative.svg"/></p> <h2>Speed ratio</h2> <p>If the first base circle rotates at the angular speed J1, the point of contact C moves at the linear speed <code>VC = J1*br1</code>. We also have <code>VC = J2*br2</code>. The counter gearwheel rotates then at the angular speed <code>J2 = VC/br2 = J1*br1/br2</code>. So the angular speed ratio is the inverse ratio of the radius of the base circles.</p> <p>In order to switch smoothly from one tooth to an other, this ratio must also be equal to <code>N1/N2</code>.</p> <p>Finaly we have <code>J2/J1 = br1/br2 = N1/N2</code>.</p> <h2>Calculation of initAngle2</h2> <p><img alt="calculation_of_initAngle2.svg"/></p> <p>Recipe to calculate the initAngle2 for the right side:</p> <ul><li>Starting from <em>initAngle1</em>, the angle position of the primary point of the first tooth</li> <li>substract the angle <em>W-primary-1</em> to get the starting of the <em>involute of circle</em></li> <li>In a loop, substract the tooth angle period to get the first angle aBP for start of <em>involute of circle</em></li> <li>Compute the length lBD of the action line</li> <li>Compute the length on the action line between two contact points: <code>2*PI/N1*brr1 = 2*PI/N2*brr2</code></li> <li>Get the first start of <em>involute of circle</em> in the second gearwheel coordinate <code>lBD-aBP*brr1</code></li> <li>Get the first start of <em>involute of circle</em> of the second gearwheel</li> <li>Get the angle position of the primary point <em>initAngle2</em> of the <em>arbitrary</em> first tooth of the second gearwheel by adding the angle <em>W-primary-2</em></li></ul> <h2>Angle kitchen</h2> <p><img alt="right_side_angle_kitchen.svg"/> <img alt="left_side_angle_kitchen.svg"/></p>',1);function ue(B,u){const I=Z(u,["children","$$slots","$$events","$$legacy"]);E(u,!1),Y(),te(B,ee(()=>I,()=>C,{children:(A,ae)=>{var v=oe(),r=K(v),$=a(r,!0);n(r);var s=t(r,6),_=a(s),J=t(_,2);n(s);var c=t(s,2),P=a(c);f(P,()=>`<code class="language-undefined">OB=R
BC=arc(BA)=u*R
L=OC=sqrt(R**2+(u*R)**2)=R*sqrt(1+u**2)
u=v+w
v=atan(u*R/R)=atan(u) if u&lt;PI/2
w=u-v=u-atan(u)
u=sqrt((L/R)**2-1)
u=f(w)? [I don&#39;t know how to calculate analytically u from w]</code>`),n(c);var h=t(c,8),T=a(h);f(T,()=>'<code class="language-undefined">u -&gt; [L: R*sqrt(1+u**2), w: u-atan(u)]</code>'),n(h);var p=t(h,4),w=a(p),W=t(w,2);n(p);var g=t(p,2),k=a(g);f(k,()=>`<code class="language-undefined">if we choose u2=-j=i1-i2, then
- C is on BF
- BC = R*u2 = -j*R = R*i1-R*i2
- dBC/dt = -R*di2/dt = R*dj/dt
- inclination of tangent in C = i1</code>`),n(g);var m=t(g,12),b=a(m),x=t(b,2);n(m);var d=t(m,12),L=a(d);n(d);var y=t(d,8),R=a(y),N=t(R,2);n(y),M((j,q,D,F,S,G,V,z,O)=>{X($,ie),l(_,"src",j),l(J,"src",q),l(w,"src",D),l(W,"src",F),l(b,"src",S),l(x,"src",G),l(L,"src",V),l(R,"src",z),l(N,"src",O)},[()=>(i(e),o(()=>e("/pgdsvg/involute_of_circle_R0.svg"))),()=>(i(e),o(()=>e("/pgdsvg/negative_involute_of_circle_R0.svg"))),()=>(i(e),o(()=>e("/pgdsvg/involute_of_circle_Ri1_u0.svg"))),()=>(i(e),o(()=>e("/pgdsvg/involute_of_circle_Ri2_u2.svg"))),()=>(i(e),o(()=>e("/pgdsvg/point_c_position_and_speed_positive.svg"))),()=>(i(e),o(()=>e("/pgdsvg/point_c_position_and_speed_negative.svg"))),()=>(i(e),o(()=>e("/pgdsvg/calculation_of_initAngle2.svg"))),()=>(i(e),o(()=>e("/pgdsvg/right_side_angle_kitchen.svg"))),()=>(i(e),o(()=>e("/pgdsvg/left_side_angle_kitchen.svg")))]),Q(A,v)},$$slots:{default:!0}})),H()}export{ue as component};
