import"../chunks/DsnmJJEf.js";import"../chunks/KVwREm06.js";import{f as Ae,a as Ie,s as e,d as s,t as Pe,b as je,r as i}from"../chunks/DDEMFpgR.js";import{s as We}from"../chunks/BRgS8L5A.js";import{s as t}from"../chunks/BjLAz-Yc.js";import{l as Re,s as Te}from"../chunks/CNFyQYs2.js";import{D as Ye}from"../chunks/BYj1kNXT.js";import{b as r}from"../chunks/Cwx_AFnf.js";const Q={title:"Geom's developer docs",category:"documentation"},{title:De,category:Ue}=Q;var Le=Ae(`<h1> </h1> <h2>Triangle</h2> <h3>Right triangle</h3> <p><img alt="right_triangle.svg"/></p> <h3>Any triangle</h3> <p><img alt="any_triangle.svg"/></p> <p>Arcsin returns only values within [-PI/2, PI/2]. If you use the <em>law of sinus</em> to get an angle, make sure this angle is acute.</p> <h2>Point</h2> <h3>Point polar coordinates</h3> <p><img alt="point_1.svg"/></p> <h3>Basic point transforms</h3> <p><img alt="point_2.svg"/> <img alt="point_3.svg"/></p> <h3>Measurements between 2 points</h3> <p><img alt="point_4.svg"/></p> <h3>Create a point from 2 points</h3> <p><img alt="point_5.svg"/></p> <h2>Line</h2> <h3>Line and X-axis</h3> <p><img alt="line_getAxisXIntersection.svg"/> <img alt="line_getAxisXIntersection_2.svg"/> <img alt="line_axis_x_cases.svg"/></p> <h3>Line and Y-axis</h3> <p><img alt="line_getAxisYIntersection.svg"/> <img alt="line_getAxisYIntersection_2.svg"/> <img alt="line_getAxisYIntersection_3.svg"/> <img alt="line_axis_y_cases.svg"/></p> <h3>Projection of origin on line</h3> <p><img alt="line_distanceOrig.svg"/></p> <h3>Projection of point on line</h3> <p><img alt="line_projectPoint.svg"/></p> <h3>Line intersection and bisector</h3> <p><img alt="line_intersection.svg"/> <img alt="construction_of_line_intersection_1.svg"/> <img alt="construction_of_line_intersection_2.svg"/></p> <h2>Vector</h2> <p>A vector is defined by its orientation and its length.</p> <p><img alt="vector_definition.svg"/></p> <h2>Contour</h2> <h3>Contour description</h3> <p>A <em>Contour</em> object defines a closed path that consists of segments and arcs.
A <em>ContourCircle</em> object defines a circle.</p> <p><em>arc</em> are defined differently in <em>canvas-js</em> and in <em>svg-path</em>.</p> <p><img alt="arc_definition.svg"/></p> <p><em>Contour</em> has 3 methods to define arcs.</p> <p><img alt="contour_arc_definition_options.svg"/></p> <p><em>Point</em> and <em>Stroke</em> can be defined relative to the previous point or absolute, with cartesian or polar coordinates. Relative coordines refer to the extremity of the last segment (stroke or arc). In particular, in case of two consecutive points, the second point, if defined with relative coordinates, refers to the previous segment and not to the previous point.</p> <p><em>addPointRP</em> and <em>addSegStrokeRP</em> use relative polar coordinate. The angle of the polar coordinate is relative to the horizontal axis. It is not relative to the previous segment orientation.</p> <p><img alt="contour_point_absolute_relative.svg"/></p> <p><em>2-arc</em> defined by two points and there two tangents</p> <p><img alt="contour_tangential_two_arcs_requirements.svg"/> <img alt="contour_tangential_two_arcs.svg"/> <img alt="contour_tangential_two_arcs_impossible_case.svg"/></p> <h3>Contour generation</h3> <h4>Pointed Corner</h4> <p><em>contour().addCornerPointed()</em> does not modify the corner.</p> <h4>Rounded Corner</h4> <h5>Defintion of Rounded Corner</h5> <p><em>contour().addCornerRounded(radius)</em> replaces the peak with an arc within the angle/peak. There is one optimal solution for the problematic.</p> <p><img alt="corner_rounded_stroke_stroke.svg"/> <img alt="corner_rounded_stroke_int_arc.svg"/> <img alt="corner_rounded_stroke_ext_arc.svg"/> <img alt="corner_rounded_ext_arc_ext_arc.svg"/> <img alt="corner_rounded_int_arc_ext_arc.svg"/> <img alt="corner_rounded_int_arc_int_arc.svg"/></p> <h5>Construction of Rounded Corner</h5> <h6>method-1</h6> <p>The method-1 is not recommended because the line intersection can generate point very far and then deals with very big numbers.</p> <p><img alt="construct_corner_rounded_stroke_stroke.svg"/> <img alt="construct_corner_rounded_stroke_int_arc.svg"/> <img alt="construct_corner_rounded_stroke_int_arc.svg"/> <img alt="construct_corner_rounded_stroke_ext_arc.svg"/> <img alt="construct_corner_rounded_stroke_ext_arc.svg"/> <img alt="construct_corner_rounded_ext_arc_ext_arc.svg"/> <img alt="construct_corner_rounded_int_arc_ext_arc.svg"/> <img alt="construct_corner_rounded_int_arc_int_arc.svg"/></p> <h6>method-2</h6> <p>The method-2 is more stable because of the orthogonal projection.</p> <p><img alt="construct_corner_rounded_stroke_int_arc_method2.svg"/> <img alt="construct_corner_rounded_stroke_ext_arc_method2.svg"/></p> <h4>Widened Corner</h4> <h5>Defintion of Widened Corner</h5> <p><em>contour().addCornerWidened(radius)</em> replaces the peak with an arc around the angle/peak. There are many possibilities to fulfil the problematic. The selected solution is to have the center of the arc on the bisector of the peak-angle. If you want to widen the corner in an other way, you have to design it yourself with strokes and arcs.</p> <h5>Construction of Widened Corner</h5> <p><img alt="construct_corner_widened.svg"/></p> <h4>Wide-Access Corner</h4> <h5>Defintion of Wide-Access Corner</h5> <p><em>contour().addCornerWideacc(radius)</em> is similar to the previous <em>Widended</em> but <em>strokes</em> might be added to provide an access of wide <em>2 x radius</em> up to the corner. Use this corner-type, if you widen the corner to provide an access to the cutter-tool.</p> <h5>Construction of Wide-Access Corner</h5> <p><img alt="construct_corner_wideacc.svg"/></p> <h4>Corner summary</h4> <table class="svelte-fitly4"><thead class="svelte-fitly4"><tr class="svelte-fitly4"><th class="svelte-fitly4">Corner options</th><th class="svelte-fitly4">jutting corner</th><th class="svelte-fitly4">recess corner</th></tr></thead><tbody class="svelte-fitly4"><tr class="svelte-fitly4"><td class="svelte-fitly4"><em>corner pointed</em></td><td class="svelte-fitly4">no change</td><td class="svelte-fitly4">no change</td></tr><tr class="svelte-fitly4"><td class="svelte-fitly4"><em>corner rounded</em></td><td class="svelte-fitly4">remove material</td><td class="svelte-fitly4">add material</td></tr><tr class="svelte-fitly4"><td class="svelte-fitly4"><em>corner widened</em></td><td class="svelte-fitly4">add material</td><td class="svelte-fitly4">remove material</td></tr><tr class="svelte-fitly4"><td class="svelte-fitly4"><em>corner wideAcc</em></td><td class="svelte-fitly4">add material</td><td class="svelte-fitly4">remove material</td></tr></tbody></table> <h2>Figure</h2> <p>A <em>Figure</em> object consists in several lists:</p> <ol><li>list of points</li> <li>list of lines</li> <li>list of vectors</li> <li>list of lists of contours called <em>main</em></li> <li>list of contours called <em>mainB</em> or <em>main-skeleton</em></li> <li>list of contours called <em>second</em></li> <li>list of contours called <em>secondB</em> or <em>second-skeleton</em></li> <li>list of contours called <em>dynamics</em></li></ol> <h2>Geom modules</h2> <p>The typescript library <em>Geom</em> dependes only the standard library <em>Math</em> and the standard <em>canvas</em> primitives.</p> <p>Internally, <em>Geom</em> consists of several modules organised with the following dependencies:</p> <p><img alt="geom_modules.svg"/></p>`,1);function Ve(Z,ee){const te=Re(ee,["children","$$slots","$$events","$$legacy"]);Ye(Z,Te(()=>te,()=>Q,{children:(re,Xe)=>{var I=Le(),o=Ie(I),se=s(o,!0);i(o);var n=e(o,6),ie=s(n);i(n);var a=e(n,4),oe=s(a);i(a);var c=e(a,8),ne=s(c);i(c);var _=e(c,4),P=s(_),ae=e(P,2);i(_);var g=e(_,4),ce=s(g);i(g);var l=e(g,4),_e=s(l);i(l);var v=e(l,6),j=s(v),W=e(j,2),ge=e(W,2);i(v);var d=e(v,4),R=s(d),T=e(R,2),Y=e(T,2),le=e(Y,2);i(d);var m=e(d,4),ve=s(m);i(m);var p=e(m,4),de=s(p);i(p);var u=e(p,4),D=s(u),L=e(D,2),me=e(L,2);i(u);var h=e(u,6),pe=s(h);i(h);var f=e(h,10),ue=s(f);i(f);var y=e(f,4),he=s(y);i(y);var $=e(y,6),fe=s($);i($);var x=e($,4),X=s(x),G=e(X,2),ye=e(G,2);i(x);var b=e(x,14),B=s(b),S=e(B,2),q=e(S,2),z=e(q,2),F=e(z,2),$e=e(F,2);i(b);var k=e(b,8),M=s(k),O=e(M,2),U=e(O,2),V=e(U,2),E=e(V,2),H=e(E,2),J=e(H,2),xe=e(J,2);i(k);var w=e(k,6),K=s(w),be=e(K,2);i(w);var C=e(w,10),ke=s(C);i(C);var A=e(C,10),we=s(A);i(A);var N=e(A,18),Ce=s(N);i(N),Pe(()=>{We(se,De),t(ie,"src",`${r??""}/puisvg/right_triangle.svg`),t(oe,"src",`${r??""}/puisvg/any_triangle.svg`),t(ne,"src",`${r??""}/puisvg/point_1.svg`),t(P,"src",`${r??""}/puisvg/point_2.svg`),t(ae,"src",`${r??""}/puisvg/point_3.svg`),t(ce,"src",`${r??""}/puisvg/point_4.svg`),t(_e,"src",`${r??""}/puisvg/point_5.svg`),t(j,"src",`${r??""}/puisvg/line_getAxisXIntersection.svg`),t(W,"src",`${r??""}/puisvg/line_getAxisXIntersection_2.svg`),t(ge,"src",`${r??""}/puisvg/line_axis_x_cases.svg`),t(R,"src",`${r??""}/puisvg/line_getAxisYIntersection.svg`),t(T,"src",`${r??""}/puisvg/line_getAxisYIntersection_2.svg`),t(Y,"src",`${r??""}/puisvg/line_getAxisYIntersection_3.svg`),t(le,"src",`${r??""}/puisvg/line_axis_y_cases.svg`),t(ve,"src",`${r??""}/puisvg/line_distanceOrig.svg`),t(de,"src",`${r??""}/puisvg/line_projectPoint.svg`),t(D,"src",`${r??""}/puisvg/line_intersection.svg`),t(L,"src",`${r??""}/puisvg/construction_of_line_intersection_1.svg`),t(me,"src",`${r??""}/puisvg/construction_of_line_intersection_2.svg`),t(pe,"src",`${r??""}/puisvg/vector_definition.svg`),t(ue,"src",`${r??""}/puisvg/arc_definition.svg`),t(he,"src",`${r??""}/puisvg/contour_arc_definition_options.svg`),t(fe,"src",`${r??""}/puisvg/contour_point_absolute_relative.svg`),t(X,"src",`${r??""}/puisvg/contour_tangential_two_arcs_requirements.svg`),t(G,"src",`${r??""}/puisvg/contour_tangential_two_arcs.svg`),t(ye,"src",`${r??""}/puisvg/contour_tangential_two_arcs_impossible_case.svg`),t(B,"src",`${r??""}/puisvg/corner_rounded_stroke_stroke.svg`),t(S,"src",`${r??""}/puisvg/corner_rounded_stroke_int_arc.svg`),t(q,"src",`${r??""}/puisvg/corner_rounded_stroke_ext_arc.svg`),t(z,"src",`${r??""}/puisvg/corner_rounded_ext_arc_ext_arc.svg`),t(F,"src",`${r??""}/puisvg/corner_rounded_int_arc_ext_arc.svg`),t($e,"src",`${r??""}/puisvg/corner_rounded_int_arc_int_arc.svg`),t(M,"src",`${r??""}/puisvg/construct_corner_rounded_stroke_stroke.svg`),t(O,"src",`${r??""}/puisvg/construct_corner_rounded_stroke_int_arc.svg`),t(U,"src",`${r??""}/puisvg/construct_corner_rounded_stroke_int_arc_obtuse.svg`),t(V,"src",`${r??""}/puisvg/construct_corner_rounded_stroke_ext_arc.svg`),t(E,"src",`${r??""}/puisvg/construct_corner_rounded_stroke_ext_arc_obtuse.svg`),t(H,"src",`${r??""}/puisvg/construct_corner_rounded_ext_arc_ext_arc.svg`),t(J,"src",`${r??""}/puisvg/construct_corner_rounded_int_arc_ext_arc.svg`),t(xe,"src",`${r??""}/puisvg/construct_corner_rounded_int_arc_int_arc.svg`),t(K,"src",`${r??""}/puisvg/construct_corner_rounded_stroke_int_arc_obtuse_method2.svg`),t(be,"src",`${r??""}/puisvg/construct_corner_rounded_stroke_ext_arc_obtuse_method2.svg`),t(ke,"src",`${r??""}/puisvg/construct_corner_widened.svg`),t(we,"src",`${r??""}/puisvg/construct_corner_wideacc.svg`),t(Ce,"src",`${r??""}/puisvg/geom_modules.svg`)}),je(re,I)},$$slots:{default:!0}}))}export{Ve as component};
