// write_openjscad.ts

//import type { tContour } from './contour';
//import type { tOuterInner } from './figure';
import * as segLib from './segment';
//import { midArcPoint } from './contour';
import type {
	//tPaxContour,
	tPaxFace,
	tPaxContourCircle,
	tPaxContourPath,
	tPaxSeg,
	tPaxSegArc
} from './prepare_pax';
import { PSeg } from './prepare_pax';
import type { tPaxFigures, tPaxJson } from './write_pax';
import { convTypePaxToSeg1, paxWrite } from './write_pax';
import { zeroPDef } from './designParams';
import type { tGeom } from './aaParamGeom';
import type { tVolume, tInherit, tExtrude, tBVolume } from './volume';
import { EExtrude, EBVolume } from './volume';
//import { withinZero2Pi, radToDeg } from './angle_utils';
//import { radToDeg } from './angle_utils';
import type { tAtsPoints } from './arc_to_stroke';
import { circle_to_stroke, arc_to_stroke } from './arc_to_stroke';

type tOpenjscadSeg = tAtsPoints;

const approxMaxAngle = Math.PI / 16;
const approxMaxLength = 2.0;

function ojscadSegLine(p2x: number, p2y: number): tOpenjscadSeg {
	const rSeg: tOpenjscadSeg = [[p2x, p2y]];
	return rSeg;
}
function ojscadSegArc(
	cx: number,
	cy: number,
	radius: number,
	aa1: number,
	aa2: number,
	arcCcw: boolean
): tOpenjscadSeg {
	const rSeg = arc_to_stroke(cx, cy, radius, aa1, aa2, arcCcw, approxMaxAngle, approxMaxLength);
	return rSeg;
}
function jcSegContour(paxCtr: tPaxSeg[]): tOpenjscadSeg {
	const rOjscadSeg: tOpenjscadSeg = [];
	let px1 = 0;
	let py1 = 0;
	for (const seg of paxCtr) {
		if (seg.typ === PSeg.eStart) {
			rOjscadSeg.push(...ojscadSegLine(seg.px, seg.py));
		} else if (seg.typ === PSeg.eStroke) {
			rOjscadSeg.push(...ojscadSegLine(seg.px, seg.py));
		} else if (seg.typ === PSeg.eArc) {
			try {
				const sega = seg as tPaxSegArc;
				const seg1 = new segLib.Segment1(
					convTypePaxToSeg1(sega.typ),
					sega.px,
					sega.py,
					sega.radius,
					sega.large,
					sega.ccw
				);
				const seg2 = segLib.arcSeg1To2(px1, py1, seg1);
				rOjscadSeg.push(
					...ojscadSegArc(
						seg2.pc.cx,
						seg2.pc.cy,
						seg1.radius,
						seg2.a1,
						seg2.a2,
						seg2.arcCcw
					)
				);
			} catch (emsg) {
				console.log('err730: ' + (emsg as string));
			}
			//} else {
			//	console.log(
			//		`err778: write_openjscad jcSegContour has unknown segment type ${seg.typ}`
			//	);
		}
		// all segements of Pax must update the last point
		px1 = seg.px;
		py1 = seg.py;
	}
	return rOjscadSeg;
}
function jcSegCircle(cx: number, cy: number, radius: number): tOpenjscadSeg {
	const rSeg = circle_to_stroke(cx, cy, radius, approxMaxAngle, approxMaxLength);
	return rSeg;
}

// floating precision for OpenScad export
function ff(ifloat: number): string {
	return ifloat.toFixed(4);
}

// format index
function fid(iIdx: number): string {
	return iIdx.toString().padStart(3, '0');
}

function makeContourString(iCtr: tOpenjscadSeg, ctrId: string): string {
	const pts2: string[] = [];
	for (const pt of iCtr) {
		const [px, py] = pt;
		pts2.push(`[ ${ff(px)}, ${ff(py)} ]`);
	}
	const ptStr = `[ ${pts2.join(',\n\t')} ]`;
	const rStr = `const ${ctrId} = polygon({ points: ${ptStr} });\n\n`;
	return rStr;
}

function jcFaceCircle(cx: number, cy: number, radius: number, ctrName: string): string {
	const ctr = jcSegCircle(cx, cy, radius);
	const rStr = makeContourString(ctr, ctrName);
	return rStr;
}

function jcFaceContour(paxCtr: tPaxSeg[], ctrName: string): string {
	const ctr = jcSegContour(paxCtr);
	const rStr = makeContourString(ctr, ctrName);
	return rStr;
}

function jcOneFace(ctrNames: string[], outName: string): string {
	let rStr = '';
	const outer = ctrNames[0];
	const inner = ctrNames.slice(1);
	if (inner.length > 0) {
		rStr += `${outName} = subtract( ${ctrNames.join(', ')} );\n`;
	} else {
		rStr += `${outName} = ${outer};\n`;
	}
	return rStr;
}

function jcOneFig(faceNames: string[], outName: string): string {
	let rStr = '';
	const firstFace = faceNames[0];
	const otherFace = faceNames.slice(1);
	if (otherFace.length > 0) {
		rStr += `${outName} = union( ${faceNames.join(', ')} );\n`;
	} else {
		rStr += `${outName} = ${firstFace};\n`;
	}
	return rStr;
}

class OpenjscadWrite {
	//constructor() {}
	getHeader(): string {
		const rStr = `// Generated by Parametrix

const { polygon } = require('@jscad/modeling').primitives;
//const { subtract } = require('@jscad/modeling').booleans;
//const { union, intersect, scission, subtract } = require('@jscad/modeling').booleans;
const { union, intersect, subtract } = require('@jscad/modeling').booleans;
const { extrudeLinear, extrudeRotate } = require('@jscad/modeling').extrusions;
const { translate, rotate } = require('@jscad/modeling').transforms;

const main = () => {
\n`;
		return rStr;
	}
	getOneFigure(aFaces: tPaxFace[], figName: string): string {
		let rStr = '';
		const figFaceList: string[] = [];
		for (const [faceIdx, paxFace] of aFaces.entries()) {
			const faceName = `face_${figName}_Fa${fid(faceIdx)}`;
			const faceCtrList: string[] = [];
			for (const [ctrIdx, paxCtr] of paxFace.entries()) {
				const subFaceName = `ctr_${faceName}_Ctr${fid(ctrIdx)}`;
				if (paxCtr.circle === true) {
					const paxCircle = paxCtr as tPaxContourCircle;
					rStr += jcFaceCircle(paxCircle.cx, paxCircle.cy, paxCircle.radius, subFaceName);
				} else {
					const paxPath = paxCtr as tPaxContourPath;
					rStr += jcFaceContour(paxPath.seg, subFaceName);
				}
				faceCtrList.push(subFaceName);
			}
			rStr += jcOneFace(faceCtrList, faceName);
			figFaceList.push(faceName);
		}
		rStr += jcOneFig(figFaceList, figName);
		return rStr;
	}
	getAllFigures(figs: tPaxFigures, partName: string): string {
		let rStr = '';
		for (const ifig in figs) {
			const figu = this.getOneFigure(figs[ifig], `${partName}_${ifig}`);
			rStr += figu;
		}
		return rStr;
	}
	getOneExtrude(extrud: tExtrude): string {
		let extrudMethod = 'extrudeRotate';
		let extrudOption = '{segments: 32}';
		if (extrud.extrudeMethod === EExtrude.eLinearOrtho) {
			if (extrud.length === undefined) {
				console.log('err079: design error: extrudeLinear length undefined!');
			}
			extrudMethod = 'extrudeLinear';
			extrudOption = `{height: ${extrud.length}}`;
		}
		const rStr = `
const ${extrud.outName} =
	translate( [ ${extrud.translate[0]}, ${extrud.translate[1]}, ${extrud.translate[2]}, ],
		rotate( [ ${extrud.rotate[0]}, ${extrud.rotate[1]}, ${extrud.rotate[2]}, ],
			   ${extrudMethod}( ${extrudOption}, face_${extrud.face} )
		)
	);
\n`;
		return rStr;
	}
	getAllExtrudes(extrudes: tExtrude[]): string {
		let rStr = '';
		for (const extrud of extrudes) {
			const subp = this.getOneExtrude(extrud);
			rStr += subp;
		}
		return rStr;
	}
	getOneVolume(volum: tBVolume): string {
		let vMethod = 'identity';
		switch (volum.boolMethod) {
			case EBVolume.eIntersection:
				vMethod = 'intersect';
				break;
			case EBVolume.eUnion:
				vMethod = 'union';
				break;
			case EBVolume.eSubstraction:
				vMethod = 'subtract';
				break;
		}
		const inList2 = volum.inList.join(', ');
		let rStr = `const ${volum.outName} = ${vMethod}( ${inList2} );\n`;
		if (volum.boolMethod === EBVolume.eIdentity) {
			rStr = `const ${volum.outName} = ${volum.inList[0]};\n`;
		}
		return rStr;
	}
	getAllVolumes(volumes: tBVolume[]): string {
		let rStr = '';
		for (const volum of volumes) {
			const subp = this.getOneVolume(volum);
			rStr += subp;
		}
		return rStr;
	}
	getAllSubGeoms(inherits: tInherit[]): tGeom[] {
		const rGeoms: tGeom[] = [];
		for (const inher of inherits) {
			if (!rGeoms.includes(inher.subgeom)) {
				rGeoms.push(inher.subgeom);
			}
		}
		return rGeoms;
	}
	getOneInherit(inherit: tInherit): string {
		const rStr = `
const ${inherit.outName} =
	translate( [ ${inherit.translate[0]}, ${inherit.translate[1]}, ${inherit.translate[2]}, ],
		rotate( [ ${inherit.rotate[0]}, ${inherit.rotate[1]}, ${inherit.rotate[2]}, ],
			   ${inherit.subdesign}
		)
	);
`;
		return rStr;
	}
	getAllInherits(inherits: tInherit[]): string {
		let rStr = '';
		for (const inher of inherits) {
			const subinhe = this.getOneInherit(inher);
			rStr += subinhe;
		}
		return rStr;
	}
	getVolume(vol: tVolume): string {
		let rStr = '';
		if (vol.inherits !== undefined) {
			const subGeoms = this.getAllSubGeoms(vol.inherits);
			for (const oneGeom of subGeoms) {
				const paxJson = paxWrite().getPaxJson({}, oneGeom, zeroPDef);
				rStr += this.getAllFigures(paxJson.figures, paxJson.partName);
				rStr += this.getVolume(oneGeom.vol);
			}
			rStr += this.getAllInherits(vol.inherits);
		}
		rStr += this.getAllExtrudes(vol.extrudes);
		rStr += this.getAllVolumes(vol.volumes);
		return rStr;
	}
	getFooter(partName: string): string {
		const rStr = `
return pax_${partName};
}
module.exports = { main };
`;
		return rStr;
	}
	getExportFile(pax: tPaxJson) {
		let rStr = this.getHeader();
		rStr += this.getAllFigures(pax.figures, pax.partName);
		rStr += this.getVolume(pax.volume);
		rStr += this.getFooter(pax.partName);
		return rStr;
	}
}

function ojscadWrite() {
	const rOjscadWrite = new OpenjscadWrite();
	return rOjscadWrite;
}

export { ojscadWrite };
