---
title: Geom's user docs
category: documentation
---

<script lang="ts">
	import { base } from '$app/paths';
</script>


# {title}

## Workflow

The creation of a 3D part with *Parametrix* is composed by the following steps:

1. **Concept:** brainstorming of the general ideas on a white-board
2. **Design:** With [Inkscape](https://inkscape.org/) draw all relevant faces and sections of the parts and define the parameters
3. **Architecture:** Using the *Geometrix* library, describe in *javascrit* the 3D parts from the parameters
4. **Sizing:** Compute the optimal values of the parameters for your use-case
5. **Export:** Apply the parameter values and export the 3D parts

In the traditional approach, the steps 2, 3 and 4 are usually merged together.


## Javascript description

### main steps of a Geometrix script

1. import *Geometrix*
2. [Optionally] import other parts
3. define the list of parameters
4. create the figures
5. describe the contruction of the 3D parts
6. [Optionally] define the links to the parameters of the sub-parts

### hierarchy of the description

1. a 3D part is an assembly of one or several extrusions of figures
2. a figures consists of one or several contours
3. a contour is either a circle or a closed path made of lines and arcs

## Export options

### SVG

A 2D drawing of one of the figures. It can be visualized and edited by [inkscape](https://inkscape.org/).

### DXF

A 2D drawing of one of the figures. It can be visualized and edited by [librecad](https://librecad.org/).

### OpenSCAD

1. install [OpenSCAD](https://openscad.org/)
2. run the exported script: `openscad path/to/exported-script.scad`
3. press *F6* or click on the menu *design>render*


### OpenJSCAD

Open the exported script with [OpenJSCAD](https://openjscad.xyz/)


### glTF

1. Install [gltf-transform](https://gltf-transform.dev/)
2. Execute the exported script
3. Visualize the generated *gltf-file* with this [gltf-viewer](https://gltf-viewer.donmccurdy.com/)


## Tutorial

### Simple design

[myPartA]() goes through the required [steps]() of a 3D part description.

### Parameter types

[myPartB]() illustrates the usage of the 3 types of parameters:

- numerical parameter
- dropdown parameter
- checkbox parameter

### Extrusion and 3D construction

[myPartC]() illustrates the usage of the 2 types of extrusion:

- orthogonal extrusion
- revolution extrusion

And the usage of the 4 types of boolean operations:

- identity (just an alias ot the first element of the list)
- union (merge/fuse the list of parts in one part)
- substraction (remove from the firt element of the list the overlaping portion of the rest of the list)
- intersection (common portion of all elements of the list)

### Evidences of the power of 2D technical drawings

### Contour creation with absolute/relative cartesian/polar coordinates

### Contour corner options

### Assembly or design-reuse

### Expose external design

[parame52-ui]() might expose designs externally defined (not coming from *parame52*). In this case, you must manually copy the svg-files in the *static* directoty of the *sveltekit* project *parame52-ui*.

### Common design list definition

When you develop your own 3D part library (like [parame51]()) you typically create 3 node-packages:

- parameXYZ : your 3D part library
- parameXYZ-ui : the sveltekit project to visualize your work in a Web-UI
- parameXYZ-cli : a CLI to export your work from command-line

In *parameXYZ-ui* and *parameXYZ-cli* you define the list of designs you want to expose. Usually it corresponds to the list your 3D part libray *parameXYZ* exports plus optionally ad-hoc external designs you want to expose as well in your UI-app or CLI-app.

In most cases you want to have the same list of designs for your UI-app and CLI-app. In this case, to get a common list of designs for UI-app and CLI-app, create an additional node-package:

- parameXYZ-list : common list of designs to be exposed in parameXYZ-ui and parameXYZ-cli

[parame52-list]() illustrates such node-package. Then [parame52-ui]() and [parame52]() have to be updated rarely.

### Assembly using external design

Previously we have seen that the UI-app and CLI-app can expose external designs. Now, [parame52]() illustrates how a new design can reuse an external design.

### Contour with arcs

### Functions defining a Contour

### Transitive reuse of external designs

### Defining sub-designs

### Add points, lines, vectors and dynamics decorations


## Technical details

### Notes on Part-name

Two design-definition could have the same partName. This is not recommended but possible. In this case if they have parameters with identical name, their values will be shared.
Also the map (partName: link) will allow you defining a single link per partName. So one of your design-definition can not be pointed by the link.

### SVG files

The svg-files that described a design and its parameters are not embedded in the *design* library. The SVG files associated to the designs you want to bind to your WebUI must be *manually* copy from the sources to the *static* folder of your *sveltekit* project.

#### Failed experiment of embedding the svg-files

There was an attempt to *inline* those svg-files into the typescript-library using [svgfiles2js](https://www.npmjs.com/package/svgfiles2js). The size of the library becomes at least five time larger and *svelte* complained about the usage of *&#123@html &#125* and the size of the bundles. So this experiment has been abandonned and reverted (commit d1517c13^..d566729d).

```bash
git diff --name-only d1517c13^..d566729d
```

#### Other idea for embedding the svg-files

An other way of embedding the svg-files in the design library would be to create a companion nodejs-CLI-tool that contains the svg-files and writes them in the target WebUI. So each design library would consist of the *browser/nodejs* library and the companion nodejs-cli-app for transferring the svg-files.


<style lang="scss">
	@use '$lib/style/colors.scss';

	h1 {
		margin: 1rem;
	}
</style>
